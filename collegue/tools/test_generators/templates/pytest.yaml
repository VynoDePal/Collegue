# Pytest Test Generation Templates
# Templates for generating Python tests with pytest framework

test_structure:
  imports: |
    import pytest
    from unittest.mock import Mock, patch, MagicMock
    {additional_imports}

  function_test: |
    def test_{function_name}():
        """Test {function_name} function."""
        # Arrange
        {setup_code}
        
        # Act
        {call_code}
        
        # Assert
        {assertions}

  class_test: |
    class Test{class_name}:
        """Test suite for {class_name} class."""
        
        def setup_method(self):
            """Setup before each test method."""
            {setup_code}
        
        def test_{method_name}(self):
            """Test {method_name} method."""
            # Arrange
            {arrange_code}
            
            # Act
            {act_code}
            
            # Assert
            {assertions}

  fixture_template: |
    @pytest.fixture
    def {fixture_name}():
        """Fixture providing {fixture_description}."""
        {fixture_code}
        return {fixture_return}

  mock_template: |
    @patch('{target_module}.{target_name}')
    def test_{function_name}_with_mock(mock_{target_name}):
        """Test {function_name} with mocked dependencies."""
        # Configure mock
        mock_{target_name}.return_value = {mock_return}
        
        # Execute
        {call_code}
        
        # Verify
        mock_{target_name}.assert_called_once_with({expected_args})

patterns:
  simple_function: |
    def test_{name}():
        result = {function_call}
        assert result is not None

  parameterized: |
    @pytest.mark.parametrize("{param_names}", [
        ({param_values_1}),
        ({param_values_2}),
    ])
    def test_{name}({params}):
        result = {function_call}
        assert result == expected

  async_function: |
    @pytest.mark.asyncio
    async def test_{name}():
        result = await {function_call}
        assert result is not None

assertions:
  equals: "assert {actual} == {expected}"
  not_none: "assert {value} is not None"
  raises: |
    with pytest.raises({exception_type}):
        {code}
  contains: "assert {substring} in {string}"
  almost_equal: "assert abs({actual} - {expected}) < {tolerance}"
